<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[alem0lars website & blog]]></title><description><![CDATA[Personal website & blog of Alessandro Molari, featuring current state of his CyberSecurity research, related news and activities]]></description><link>https://alessandro.molari.me</link><generator>RSS for Node</generator><lastBuildDate>Mon, 18 Jun 2018 09:44:10 GMT</lastBuildDate><item><title><![CDATA[Reversing Delphi Programs - Part 1]]></title><description><![CDATA[This is the first article of the ” Reversing Delphi Programs ” series. In this article we will explore the  conventions  normally used by…]]></description><link>https://alessandro.molari.me/reversing-delphi-programs-p1/</link><guid isPermaLink="false">https://alessandro.molari.me/reversing-delphi-programs-p1/</guid><content:encoded>&lt;p&gt;This is the first article of the ”&lt;strong&gt;Reversing Delphi Programs&lt;/strong&gt;” series.&lt;/p&gt;
&lt;p&gt;In this article we will explore the &lt;em&gt;conventions&lt;/em&gt; normally used by Delphi compiler to generate machine code from Delphi source code.
These are the rules you may expect to see when reversing Delphi programs.&lt;/p&gt;
&lt;p&gt;The default calling convention is &lt;code class=&quot;language-text&quot;&gt;register&lt;/code&gt;.
It’s the most efficient calling convention, since it usually &lt;em&gt;avoids creation of a stack frame&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;For the &lt;code class=&quot;language-text&quot;&gt;register&lt;/code&gt; convention the cleanup is performed by the callee.&lt;/p&gt;
&lt;p&gt;Remember that system functions do not necessarily play by the same rules as ordinary functions, especially those functions that are intended to be called implicitly by compiler-generated code instead of being invoked explicitly by user code. The compiler may have extended information on these system functions, like clobbered registers, unusual parameter locations, &lt;code class=&quot;language-text&quot;&gt;nothrow&lt;/code&gt;, &lt;code class=&quot;language-text&quot;&gt;noreturn&lt;/code&gt; and so on.
This extended information could be in System unit meta data or hardcoded directly into the compiler.&lt;/p&gt;
&lt;h2&gt;Parameters conventions&lt;/h2&gt;
&lt;p&gt;Up to three parameters are passed in CPU registers, and the rest (if any) are passed on the stack.&lt;/p&gt;
&lt;p&gt;The parameters are passed in order of declaration (left to right).&lt;/p&gt;
&lt;p&gt;The first three parameters that qualify are passed in the &lt;code class=&quot;language-text&quot;&gt;EAX&lt;/code&gt;, &lt;code class=&quot;language-text&quot;&gt;EDX&lt;/code&gt;, and &lt;code class=&quot;language-text&quot;&gt;ECX&lt;/code&gt; registers, in that order.
The remaining parameters are pushed onto the stack in order of declaration.&lt;/p&gt;
&lt;p&gt;Real, method-pointer, variant, Int64, and structured types do not qualify as register parameters, but all other parameters do.&lt;/p&gt;
&lt;h3&gt;Example&lt;/h3&gt;
&lt;p&gt;For example, given the declaration:&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot;&gt;
      &lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;procedure Test(A: Integer;
               var B: Char;
               C: Double;
               const D: string;
               E: Pointer);&lt;/code&gt;&lt;/pre&gt;
      &lt;/div&gt;
&lt;p&gt;A call to &lt;code class=&quot;language-text&quot;&gt;Test&lt;/code&gt; passes:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;A&lt;/code&gt; in &lt;code class=&quot;language-text&quot;&gt;EAX&lt;/code&gt; as a 32-bit integer&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;B&lt;/code&gt; in &lt;code class=&quot;language-text&quot;&gt;EDX&lt;/code&gt; as a pointer to a &lt;code class=&quot;language-text&quot;&gt;Char&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;D&lt;/code&gt; in &lt;code class=&quot;language-text&quot;&gt;ECX&lt;/code&gt; as a pointer to a long-string memory block&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;C&lt;/code&gt; and &lt;code class=&quot;language-text&quot;&gt;E&lt;/code&gt; are pushed onto the stack as two double-words and a 32-bit pointer, in that order&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Registers saving conventions&lt;/h2&gt;
&lt;p&gt;Procedures and functions &lt;em&gt;must preserve&lt;/em&gt; the &lt;code class=&quot;language-text&quot;&gt;EBX&lt;/code&gt;, &lt;code class=&quot;language-text&quot;&gt;ESI&lt;/code&gt;, &lt;code class=&quot;language-text&quot;&gt;EDI&lt;/code&gt;, and &lt;code class=&quot;language-text&quot;&gt;EBP&lt;/code&gt; registers, but &lt;em&gt;can modify&lt;/em&gt; the &lt;code class=&quot;language-text&quot;&gt;EAX&lt;/code&gt;, &lt;code class=&quot;language-text&quot;&gt;EDX&lt;/code&gt;, and &lt;code class=&quot;language-text&quot;&gt;ECX&lt;/code&gt; registers.&lt;/p&gt;
&lt;p&gt;Constructor or destructors preserve the &lt;code class=&quot;language-text&quot;&gt;DL&lt;/code&gt; register.&lt;/p&gt;
&lt;p&gt;When working with the MMX and XMM instructions, functions must preserve the values of the &lt;code class=&quot;language-text&quot;&gt;xmm&lt;/code&gt; and &lt;code class=&quot;language-text&quot;&gt;mm&lt;/code&gt; registers.
Delphi functions do not make any assumptions about the state and content of &lt;code class=&quot;language-text&quot;&gt;xmm&lt;/code&gt; registers.
They do not guarantee that the content of &lt;code class=&quot;language-text&quot;&gt;xmm&lt;/code&gt; registers is unchanged.&lt;/p&gt;
&lt;h2&gt;Function results conventions&lt;/h2&gt;
&lt;p&gt;The following conventions are used for returning function result values.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;http://docwiki.embarcadero.com/RADStudio/Tokyo/en/Simple_Types_(Delphi)#Ordinal_Types&quot;&gt;Ordinal&lt;/a&gt; results are returned, when possible, in a CPU register:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Bytes are returned in &lt;code class=&quot;language-text&quot;&gt;AL&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Words are returned in &lt;code class=&quot;language-text&quot;&gt;AX&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Double-words are returned in &lt;code class=&quot;language-text&quot;&gt;EAX&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Real results are returned in the floating-point coprocessor’s top-of-stack register &lt;code class=&quot;language-text&quot;&gt;ST(0)&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;For function results of type &lt;a href=&quot;http://docwiki.embarcadero.com/Libraries/Tokyo/en/System.Currency&quot;&gt;Currency&lt;/a&gt;, the value in &lt;code class=&quot;language-text&quot;&gt;ST(0)&lt;/code&gt; is scaled by &lt;code class=&quot;language-text&quot;&gt;10000&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;For example, the Currency value &lt;code class=&quot;language-text&quot;&gt;1.234&lt;/code&gt; is returned in &lt;code class=&quot;language-text&quot;&gt;ST(0)&lt;/code&gt; as &lt;code class=&quot;language-text&quot;&gt;12340&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;For a string, dynamic array, method pointer, or variant result, the effects are the same as if the function result were declared as an additional var parameter following the declared parameters. In other words, &lt;em&gt;the caller passes an additional 32-bit pointer that points to a variable in which to return the function result&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://docwiki.embarcadero.com/Libraries/Tokyo/en/System.Int64&quot;&gt;Int64&lt;/a&gt; is returned in &lt;code class=&quot;language-text&quot;&gt;EDX:EAX&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://docwiki.embarcadero.com/Libraries/Tokyo/en/System.Pointer&quot;&gt;Pointer&lt;/a&gt;, class, class-reference, and procedure-pointer results are returned in &lt;code class=&quot;language-text&quot;&gt;EAX&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;For static-array, record, and set results:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;If the value occupies one byte it is returned in &lt;code class=&quot;language-text&quot;&gt;AL&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;If the value occupies two bytes it is returned in &lt;code class=&quot;language-text&quot;&gt;AX&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;If the value occupies four bytes it is returned in &lt;code class=&quot;language-text&quot;&gt;EAX&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Otherwise, the result is returned in an additional var parameter that is passed to the function after the declared parameters&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Methods conventions&lt;/h2&gt;
&lt;p&gt;Methods are like functions but associated with the underlying object (Delphi is Object-Oriented).&lt;/p&gt;
&lt;p&gt;Methods use the &lt;em&gt;same calling conventions&lt;/em&gt; as ordinary procedures and functions, except that every method has an &lt;em&gt;additional implicit parameter&lt;/em&gt; &lt;code class=&quot;language-text&quot;&gt;Self&lt;/code&gt;, which is a reference to the instance or class in which the method is called.&lt;/p&gt;
&lt;p&gt;Under the &lt;code class=&quot;language-text&quot;&gt;register&lt;/code&gt; convention, &lt;code class=&quot;language-text&quot;&gt;Self&lt;/code&gt; behaves as if it were declared before all other parameters. It is therefore always passed in the &lt;code class=&quot;language-text&quot;&gt;EAX&lt;/code&gt; register.&lt;/p&gt;
&lt;p&gt;The &lt;code class=&quot;language-text&quot;&gt;Self&lt;/code&gt; parameter is passed as a 32-bit pointer.&lt;/p&gt;
&lt;h2&gt;Constructors and Destructors conventions&lt;/h2&gt;
&lt;p&gt;Constructors and destructors use the same calling conventions as other methods, except that an additional Boolean &lt;code class=&quot;language-text&quot;&gt;flag&lt;/code&gt; parameter is passed to &lt;em&gt;indicate the context of the constructor or destructor call&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;The flag parameter behaves as if it were declared before all other parameters. It is passed in the &lt;code class=&quot;language-text&quot;&gt;DL&lt;/code&gt; register.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;In constructors:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;True&lt;/code&gt;: indicates that the constructor was &lt;em&gt;invoked through a class reference&lt;/em&gt;. In this case, the constructor creates an instance of the class given by &lt;code class=&quot;language-text&quot;&gt;Self&lt;/code&gt;, and returns a reference to the newly created object in &lt;code class=&quot;language-text&quot;&gt;EAX&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;False&lt;/code&gt;: indicates that the constructor was &lt;em&gt;invoked through an instance object or using the inherited keyword&lt;/em&gt;. In this case, the constructor behaves like an ordinary method&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;In destructors:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;True&lt;/code&gt;: indicates that the destructor was &lt;em&gt;invoked through an instance object&lt;/em&gt;. In this case, the destructor deallocates the instance given by &lt;code class=&quot;language-text&quot;&gt;Self&lt;/code&gt; just before returning&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;False&lt;/code&gt;: indicates that the destructor was &lt;em&gt;invoked using the inherited keyword&lt;/em&gt;. In this case, the destructor behaves like an ordinary method&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Sources&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.hackthebox.eu&quot;&gt;Hack the Box&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://docwiki.embarcadero.com/RADStudio/Tokyo/en/Delphi_Data_Types_for_API_Integration&quot;&gt;Data Types&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://docwiki.embarcadero.com/RADStudio/Tokyo/en/Procedures_and_Functions_(Delphi)&quot;&gt;Procedures and Functions&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://docwiki.embarcadero.com/RADStudio/Tokyo/en/Program_Control_(Delphi)&quot;&gt;Program Control&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;!-- Pointers --&gt;</content:encoded></item><item><title><![CDATA[Generating Entropy in Linux]]></title><description><![CDATA[In Linux, sometimes you may need to generate some entropy. Solutions There are both  hardware  and  software  solutions: Hardware solutions…]]></description><link>https://alessandro.molari.me/generating-entropy-in-linux/</link><guid isPermaLink="false">https://alessandro.molari.me/generating-entropy-in-linux/</guid><content:encoded>&lt;p&gt;In Linux, sometimes you may need to generate some entropy.&lt;/p&gt;
&lt;h1&gt;Solutions&lt;/h1&gt;
&lt;p&gt;There are both &lt;em&gt;hardware&lt;/em&gt; and &lt;em&gt;software&lt;/em&gt; solutions:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Hardware solutions&lt;/strong&gt;: they can &lt;em&gt;generate more entropy per second&lt;/em&gt;, but you need physical access&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Software solutions&lt;/strong&gt;: they have less performance, but you just need &lt;code class=&quot;language-text&quot;&gt;root&lt;/code&gt; permissions (no physical access)&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;Hardware solutions&lt;/h1&gt;
&lt;p&gt;Typically it’s a USB device that &lt;em&gt;generates and streams some random numbers&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;One of such devices is &lt;a href=&quot;http://ubld.it/products/truerng-hardware-random-number-generator&quot;&gt;TrueRNG&lt;/a&gt; (price is approx: 50$).&lt;/p&gt;
&lt;h1&gt;Software solutions&lt;/h1&gt;
&lt;h2&gt;RNGD&lt;/h2&gt;
&lt;p&gt;This program feeds random data from hardware device to kernel.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot;&gt;
      &lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;rngd -r &amp;quot;/dev/urandom&amp;quot;&lt;/code&gt;&lt;/pre&gt;
      &lt;/div&gt;
&lt;p&gt;Here we have used &lt;code class=&quot;language-text&quot;&gt;rngd&lt;/code&gt; program (&lt;a href=&quot;http://linux.die.net/man/8/rngd&quot;&gt;man 8 rngd&lt;/a&gt; for more details).&lt;/p&gt;
&lt;p&gt;This daemon feeds data from a random number generator to the kernel’s random number entropy pool, after first checking the data to ensure that it is properly random.&lt;/p&gt;
&lt;h2&gt;Audio Entropy Daemon&lt;/h2&gt;
&lt;p&gt;This program feeds the &lt;code class=&quot;language-text&quot;&gt;/dev/random&lt;/code&gt; device with entropy-data read from an audio device.&lt;/p&gt;
&lt;p&gt;The audio-data is not copied as is but first &lt;em&gt;de-biased&lt;/em&gt; and analysed to determine how much bits of entropy is in it.&lt;/p&gt;
&lt;p&gt;The official website of the program is &lt;a href=&quot;https://www.vanheusden.com/aed&quot;&gt;here&lt;/a&gt;.&lt;/p&gt;</content:encoded></item></channel></rss>